# üåê NETWORK PROGRAMMING - THUY·∫æT TR√åNH

## üìã **M·ª•c L·ª•c**
1. [G·ª≠i Tin Nh·∫Øn C√° Nh√¢n](#g·ª≠i-tin-nh·∫Øn-c√°-nh√¢n)
2. [Nh·∫≠n Tin Nh·∫Øn Real-time](#nh·∫≠n-tin-nh·∫Øn-real-time)
3. [Socket.IO Connection](#socketio-connection)
4. [Video Call - WebRTC Signaling](#video-call---webrtc-signaling)
5. [Qu·∫£n L√Ω Tin Nh·∫Øn Ch∆∞a ƒê·ªçc](#qu·∫£n-l√Ω-tin-nh·∫Øn-ch∆∞a-ƒë·ªçc)
6. [Flow Ho√†n Ch·ªânh](#flow-ho√†n-ch·ªânh)

---

## üöÄ **G·ª¨I TIN NH·∫ÆN C√Å NH√ÇN**

### **1. Frontend - User Interface**

```javascript
// File: frontend/src/components/MessageInput.jsx
const handleSendMessage = async (e) => {
  e.preventDefault();
  if (!text.trim() && !imagePreview) return;

  setIsSending(true);
  try {
    await sendMessage({
      text: text.trim(),
      image: imagePreview,
    });
    setText("");
    setImagePreview(null);
  } catch (error) {
    console.error("Error sending message:", error);
  } finally {
    setIsSending(false);
  }
};
```

**C√°ch ho·∫°t ƒë·ªông:**
1. **`e.preventDefault()`**: NgƒÉn browser t·ª± ƒë·ªông reload trang khi submit form (h√†nh vi m·∫∑c ƒë·ªãnh c·ªßa HTML form)
2. **`text.trim()`**: Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a ·ªü ƒë·∫ßu v√† cu·ªëi chu·ªói ƒë·ªÉ tr√°nh g·ª≠i tin nh·∫Øn r·ªóng
3. **`setIsSending(true)`**: Hi·ªÉn th·ªã loading spinner/button disabled ƒë·ªÉ user bi·∫øt ƒëang g·ª≠i
4. **`sendMessage()`**: G·ªçi function t·ª´ Zustand store ƒë·ªÉ x·ª≠ l√Ω logic g·ª≠i tin nh·∫Øn
5. **`setText("")`**: X√≥a n·ªôi dung input field sau khi g·ª≠i th√†nh c√¥ng
6. **`setIsSending(false)`**: T·∫Øt loading state trong m·ªçi tr∆∞·ªùng h·ª£p (th√†nh c√¥ng ho·∫∑c l·ªói)

### **2. Frontend - State Management**

```javascript
// File: frontend/src/store/useChatStore.js
sendMessage: async (messageData) => {
  const { selectedUser, selectedGroup, messages } = get();
  try {
    let res;
    if (selectedGroup) {
      res = await axiosInstance.post(
        `/groups/${selectedGroup._id}/messages`,
        messageData
      );
    } else if (selectedUser) {
      res = await axiosInstance.post(
        `/messages/send/${selectedUser._id}`,
        messageData
      );
    } else {
      toast.error("No chat selected");
      return;
    }
    set({ messages: [...messages, res.data] });
  } catch (error) {
    toast.error(error.response?.data?.message || "Failed to send message");
  }
},
```

**C√°ch ho·∫°t ƒë·ªông:**
1. **`get()`**: L·∫•y to√†n b·ªô state hi·ªán t·∫°i t·ª´ Zustand store (messages, selectedUser, selectedGroup)
2. **Ki·ªÉm tra lo·∫°i chat**: 
   - N·∫øu `selectedGroup` c√≥ gi√° tr·ªã ‚Üí ƒëang chat nh√≥m ‚Üí g·ª≠i ƒë·∫øn API `/groups/{id}/messages`
   - N·∫øu `selectedUser` c√≥ gi√° tr·ªã ‚Üí ƒëang chat c√° nh√¢n ‚Üí g·ª≠i ƒë·∫øn API `/messages/send/{id}`
3. **`axiosInstance.post()`**: G·ª≠i HTTP POST request v·ªõi d·ªØ li·ªáu tin nh·∫Øn ƒë·∫øn backend
4. **`[...messages, res.data]`: Spread operator t·∫°o array m·ªõi b·∫±ng c√°ch:
   - Copy t·∫•t c·∫£ tin nh·∫Øn c≈© (`...messages`)
   - Th√™m tin nh·∫Øn m·ªõi v√†o cu·ªëi (`res.data`)
5. **`set()`**: C·∫≠p nh·∫≠t state trong store ‚Üí trigger re-render UI t·ª± ƒë·ªông
6. **Error handling**: N·∫øu l·ªói ‚Üí hi·ªÉn th·ªã toast notification cho user

### **3. Backend - Controller**

```javascript
// File: backend/src/controllers/message.controller.js
export const sendMessage = async (req, res) => {
  try {
    const { text, image, groupId } = req.body;
    const { id: receiverId } = req.params;
    const senderId = req.user._id;

    if (!text && !image) {
      return res.status(400).json({ error: "Tin nh·∫Øn r·ªóng" });
    }

    const newMessage = new Message({
      senderId,
      receiverId: groupId ? undefined : receiverId,
      groupId: groupId || undefined,
      text,
      image: imageUrl,
    });

    await newMessage.save();

    if (groupId) {
      io.to(`group:${groupId}`).emit("newGroupMessage", newMessage);
    } else {
      const receiverSocketId = getReceiverSocketId(receiverId);
      if (receiverSocketId) {
        io.to(receiverSocketId).emit("newMessage", newMessage);
      }
    }

    res.status(201).json(newMessage);
  } catch (error) {
    console.error("Error in sendMessage:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
};
```

**C√°ch ho·∫°t ƒë·ªông:**
1. **L·∫•y d·ªØ li·ªáu t·ª´ request**:
   - `req.body`: L·∫•y n·ªôi dung tin nh·∫Øn t·ª´ frontend (text, image, groupId)
   - `req.params`: L·∫•y ID ng∆∞·ªùi nh·∫≠n t·ª´ URL (v√≠ d·ª•: `/messages/send/123` ‚Üí receiverId = "123")
   - `req.user._id`: L·∫•y ID ng∆∞·ªùi g·ª≠i t·ª´ JWT token (ƒë√£ ƒë∆∞·ª£c x√°c th·ª±c b·ªüi middleware)

2. **Validation**: Ki·ªÉm tra tin nh·∫Øn kh√¥ng r·ªóng (c√≥ text ho·∫∑c image)

3. **T·∫°o tin nh·∫Øn m·ªõi**:
   - `new Message()`: T·∫°o object tin nh·∫Øn theo schema MongoDB
   - `await newMessage.save()`: L∆∞u tin nh·∫Øn v√†o database MongoDB

4. **Real-time broadcasting**:
   - N·∫øu l√† tin nh·∫Øn nh√≥m: `io.to('group:groupId').emit()` ‚Üí g·ª≠i ƒë·∫øn t·∫•t c·∫£ th√†nh vi√™n nh√≥m
   - N·∫øu l√† tin nh·∫Øn c√° nh√¢n: `io.to(socketId).emit()` ‚Üí g·ª≠i ƒë·∫øn ng∆∞·ªùi nh·∫≠n c·ª• th·ªÉ

5. **Response**: `res.status(201).json()` ‚Üí tr·∫£ v·ªÅ tin nh·∫Øn ƒë√£ t·∫°o cho frontend

---

## üì® **NH·∫¨N TIN NH·∫ÆN REAL-TIME**

### **Frontend - Socket Listener**

```javascript
// File: frontend/src/store/useChatStore.js
listenMessages: () => {
  const socket = useAuthStore.getState().socket;
  if (!socket) return;
  
  const { selectedUser, selectedGroup } = get();
  
  socket.off("newMessage");
  socket.off("newGroupMessage");
  
  if (selectedGroup) {
    socket.on("newGroupMessage", (newMessage) => {
      if (newMessage.groupId !== selectedGroup._id) return;
      set({ messages: [...get().messages, newMessage] });
    });
  } else if (selectedUser) {
    socket.on("newMessage", (newMessage) => {
      if (newMessage.senderId !== selectedUser._id) return;
      set({ messages: [...get().messages, newMessage] });
    });
  }
},
```

**C√°ch ho·∫°t ƒë·ªông:**
1. **L·∫•y socket connection**: `useAuthStore.getState().socket` ‚Üí l·∫•y WebSocket connection hi·ªán t·∫°i

2. **Cleanup listeners c≈©**: `socket.off()` ‚Üí x√≥a c√°c event listener c≈© ƒë·ªÉ tr√°nh:
   - Memory leak (t√≠ch l≈©y listeners)
   - Duplicate messages (nh·∫≠n tin nh·∫Øn nhi·ªÅu l·∫ßn)

3. **L·∫Øng nghe tin nh·∫Øn m·ªõi**:
   - **Chat nh√≥m**: `socket.on("newGroupMessage")` ‚Üí ch·ªâ x·ª≠ l√Ω tin nh·∫Øn c·ªßa nh√≥m ƒëang chat
   - **Chat c√° nh√¢n**: `socket.on("newMessage")` ‚Üí ch·ªâ x·ª≠ l√Ω tin nh·∫Øn t·ª´ user ƒëang chat

4. **Validation**: Ki·ªÉm tra tin nh·∫Øn c√≥ thu·ªôc v·ªÅ chat hi·ªán t·∫°i kh√¥ng:
   - `newMessage.groupId !== selectedGroup._id` ‚Üí tin nh·∫Øn nh√≥m
   - `newMessage.senderId !== selectedUser._id` ‚Üí tin nh·∫Øn c√° nh√¢n

5. **C·∫≠p nh·∫≠t UI**: `[...get().messages, newMessage]` ‚Üí t·∫°o array m·ªõi (immutable) v√† `set()` ƒë·ªÉ trigger re-render

---

## üîå **SOCKET.IO CONNECTION**

### **Backend - Socket Server**

```javascript
// File: backend/src/lib/socket.js
const userSocketMap = {};

io.on("connection", (socket) => {
  console.log("A user connected:", socket.id);

  const userId = socket.handshake.query.userId;
  if (userId) {
    userSocketMap[userId] = socket.id;
    console.log("User online:", userId);
    
    socket.broadcast.emit("userOnline", userId);
  }

  const onlineUserIds = Object.keys(userSocketMap);
  io.emit("getOnlineUsers", onlineUserIds);

  socket.on("disconnect", () => {
    console.log("A user disconnected:", socket.id);
    if (userId) {
      delete userSocketMap[userId];
      socket.broadcast.emit("userOffline", userId);
    }
  });
});
```

**C√°ch ho·∫°t ƒë·ªông:**
1. **Khi user k·∫øt n·ªëi**:
   - `socket.handshake.query.userId`: L·∫•y userId t·ª´ query string (frontend g·ª≠i khi connect)
   - `userSocketMap[userId] = socket.id`: L∆∞u mapping userId ‚Üí socketId ƒë·ªÉ bi·∫øt user n√†o ƒëang online

2. **Th√¥ng b√°o user online**:
   - `socket.broadcast.emit("userOnline", userId)`: Th√¥ng b√°o cho T·∫§T C·∫¢ user kh√°c (tr·ª´ user v·ª´a connect)
   - `io.emit("getOnlineUsers", onlineUserIds)`: G·ª≠i danh s√°ch user online cho T·∫§T C·∫¢ clients

3. **Khi user disconnect**:
   - `delete userSocketMap[userId]`: X√≥a user kh·ªèi map (kh√¥ng c√≤n online)
   - `socket.broadcast.emit("userOffline", userId)`: Th√¥ng b√°o user ƒë√£ offline
   - C·∫≠p nh·∫≠t l·∫°i danh s√°ch user online cho t·∫•t c·∫£ clients

4. **Qu·∫£n l√Ω state**:
   - `userSocketMap`: Object l∆∞u tr·ªØ {userId: socketId} ƒë·ªÉ bi·∫øt user n√†o ƒëang online
   - `Object.keys(userSocketMap)`: L·∫•y danh s√°ch t·∫•t c·∫£ userId ƒëang online

---

## üìπ **VIDEO CALL - WEBRTC SIGNALING**

### **Backend - Call Signaling**

```javascript
// File: backend/src/lib/socket.js
const videoCallMap = {};

socket.on("initiateCall", ({ receiverId, callType = "voice" }) => {
  const callerId = userId;
  const callId = `${callerId}-${receiverId}-${Date.now()}`;
  
  videoCallMap[callId] = {
    callerId,
    receiverId,
    callType,
    status: "ringing",
    startTime: new Date()
  };
  
  const receiverSocketId = getReceiverSocketId(receiverId);
  if (receiverSocketId) {
    io.to(receiverSocketId).emit("incomingCall", {
      callId,
      callerId,
      callType,
      callerInfo: { userId: callerId }
    });
  }
  
  socket.emit("callInitiated", { callId, receiverId });
});
```

**C√°ch ho·∫°t ƒë·ªông:**
1. **T·∫°o cu·ªôc g·ªçi**:
   - `callId`: T·∫°o unique ID = `${callerId}-${receiverId}-${timestamp}` (v√≠ d·ª•: "123-456-1704067200000")
   - `videoCallMap[callId]`: L∆∞u th√¥ng tin cu·ªôc g·ªçi v√†o memory v·ªõi status "ringing"

2. **G·ª≠i th√¥ng b√°o cu·ªôc g·ªçi**:
   - `getReceiverSocketId(receiverId)`: T√¨m socket ID c·ªßa ng∆∞·ªùi nh·∫≠n cu·ªôc g·ªçi
   - `io.to(receiverSocketId).emit("incomingCall")`: G·ª≠i th√¥ng b√°o cu·ªôc g·ªçi ƒë·∫øn ƒë·∫øn ng∆∞·ªùi nh·∫≠n

3. **X√°c nh·∫≠n kh·ªüi t·∫°o**:
   - `socket.emit("callInitiated")`: Th√¥ng b√°o cho ng∆∞·ªùi g·ªçi r·∫±ng cu·ªôc g·ªçi ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o th√†nh c√¥ng

4. **Qu·∫£n l√Ω tr·∫°ng th√°i**:
   - `status: "ringing"`: Cu·ªôc g·ªçi ƒëang ƒë·ªï chu√¥ng
   - C√°c tr·∫°ng th√°i kh√°c: "accepted", "rejected", "ended"
   - `videoCallMap`: L∆∞u tr·ªØ t·∫•t c·∫£ cu·ªôc g·ªçi ƒëang di·ªÖn ra trong memory

### **Frontend - Call Handling**

```javascript
// File: frontend/src/components/VideoCallModal.jsx
useEffect(() => {
  const { socket } = useAuthStore.getState();
  if (socket) {
    socket.on("incomingCall", (callData) => {
      console.log("Incoming call received:", callData);
      useVideoCallStore.getState().handleIncomingCall(callData);
    });

    socket.on("callAccepted", ({ callId }) => {
      console.log("Call accepted event received:", callId);
      useVideoCallStore.getState().initializePeerConnection();
    });

    socket.on("offer", ({ callId, offer }) => {
      console.log("Offer received:", callId);
      useVideoCallStore.getState().handleOffer(offer);
    });

    socket.on("answer", ({ callId, answer }) => {
      console.log("Answer received:", callId);
      useVideoCallStore.getState().handleAnswer(answer);
    });

    socket.on("iceCandidate", ({ callId, candidate }) => {
      console.log("ICE candidate received:", callId);
      useVideoCallStore.getState().handleIceCandidate(candidate);
    });
  }
}, []);
```

**C√°ch ho·∫°t ƒë·ªông:**
1. **L·∫Øng nghe cu·ªôc g·ªçi ƒë·∫øn**:
   - `socket.on("incomingCall")`: Nh·∫≠n th√¥ng b√°o cu·ªôc g·ªçi t·ª´ server
   - `handleIncomingCall()`: Hi·ªÉn th·ªã modal "Incoming Call" v·ªõi n√∫t Accept/Reject

2. **X·ª≠ l√Ω ch·∫•p nh·∫≠n cu·ªôc g·ªçi**:
   - `socket.on("callAccepted")`: Nh·∫≠n th√¥ng b√°o cu·ªôc g·ªçi ƒë∆∞·ª£c ch·∫•p nh·∫≠n
   - `initializePeerConnection()`: Kh·ªüi t·∫°o WebRTC peer connection ƒë·ªÉ b·∫Øt ƒë·∫ßu video call

3. **WebRTC Signaling**:
   - `socket.on("offer")`: Nh·∫≠n WebRTC offer t·ª´ b√™n kia (ch·ª©a th√¥ng tin media)
   - `socket.on("answer")`: Nh·∫≠n WebRTC answer t·ª´ b√™n kia (ph·∫£n h·ªìi offer)
   - `socket.on("iceCandidate")`: Nh·∫≠n ICE candidates ƒë·ªÉ thi·∫øt l·∫≠p k·∫øt n·ªëi P2P

4. **Flow ho√†n ch·ªânh**:
   - User A g·ªçi ‚Üí User B nh·∫≠n ‚Üí User B accept ‚Üí Exchange offer/answer ‚Üí P2P connection established

---

## üì¨ **QU·∫¢N L√ù TIN NH·∫ÆN CH∆ØA ƒê·ªåC**

### **Backend - Unread Count Management**

```javascript
// File: backend/src/controllers/message.controller.js
export const getMessages = async (req, res) => {
  try {
    const { id: userToChatId } = req.params;
    const myId = req.user._id;

    const messages = await Message.find({
      $or: [
        { senderId: myId, receiverId: userToChatId },
        { senderId: userToChatId, receiverId: myId },
      ],
    }).sort({ createdAt: 1 });

    const updateResult = await Message.updateMany(
      { senderId: userToChatId, receiverId: myId, isRead: false },
      { isRead: true }
    );

    const unreadCounts = await Message.aggregate([
      {
        $match: {
          receiverId: myId,
          isRead: false,
          groupId: { $exists: false }
        }
      },
      {
        $group: {
          _id: "$senderId",
          count: { $sum: 1 }
        }
      }
    ]);
    
    const unreadMap = {};
    unreadCounts.forEach(item => {
      unreadMap[item._id.toString()] = item.count;
    });

    const receiverSocketId = getReceiverSocketId(myId);
    if (receiverSocketId) {
      io.to(receiverSocketId).emit("unreadCountsUpdate", unreadMap);
    }

    res.status(200).json(messages);
  } catch (error) {
    console.error("Error in getMessages:", error.message);
    res.status(500).json({ error: "Internal server error" });
  }
};
```

**C√°ch ho·∫°t ƒë·ªông:**
1. **L·∫•y tin nh·∫Øn gi·ªØa 2 user**:
   - `$or`: MongoDB operator t√¨m tin nh·∫Øn th·ªèa m√£n 1 trong 2 ƒëi·ªÅu ki·ªán:
     - User A g·ª≠i cho User B
     - User B g·ª≠i cho User A

2. **ƒê√°nh d·∫•u tin nh·∫Øn ƒë√£ ƒë·ªçc**:
   - `updateMany()`: C·∫≠p nh·∫≠t t·∫•t c·∫£ tin nh·∫Øn t·ª´ user kia g·ª≠i cho m√¨nh th√†nh `isRead: true`

3. **T√≠nh to√°n unread counts**:
   - `$match`: L·ªçc tin nh·∫Øn ch∆∞a ƒë·ªçc (`isRead: false`) v√† kh√¥ng ph·∫£i tin nh·∫Øn nh√≥m
   - `$group`: Nh√≥m tin nh·∫Øn theo `senderId` (ng∆∞·ªùi g·ª≠i)
   - `$sum: 1`: ƒê·∫øm s·ªë tin nh·∫Øn ch∆∞a ƒë·ªçc t·ª´ m·ªói ng∆∞·ªùi g·ª≠i

4. **Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu**:
   - `unreadMap`: Chuy·ªÉn t·ª´ array th√†nh object {userId: count} ƒë·ªÉ d·ªÖ s·ª≠ d·ª•ng

5. **Real-time update**:
   - `io.to(socketId).emit()`: G·ª≠i c·∫≠p nh·∫≠t unread counts qua socket ƒë·ªÉ UI hi·ªÉn th·ªã badge s·ªë tin nh·∫Øn ch∆∞a ƒë·ªçc

---

## üîÑ **FLOW HO√ÄN CH·ªàNH**

### **G·ª≠i Tin Nh·∫Øn - Step by Step**

1. **User nh·∫≠p tin nh·∫Øn** ‚Üí `MessageInput.jsx`
2. **Click Send** ‚Üí `handleSendMessage()`
3. **Store x·ª≠ l√Ω** ‚Üí `useChatStore.sendMessage()`
4. **HTTP Request** ‚Üí `axiosInstance.post()`
5. **Backend nh·∫≠n** ‚Üí `message.controller.sendMessage()`
6. **L∆∞u Database** ‚Üí `newMessage.save()`
7. **Socket emit** ‚Üí `io.to(socketId).emit("newMessage")`
8. **Real-time receive** ‚Üí `socket.on("newMessage")`
9. **UI update** ‚Üí `set({ messages: [...messages, newMessage] })`

### **Video Call - Step by Step**

1. **User A click call** ‚Üí `socket.emit("initiateCall")`
2. **Backend signaling** ‚Üí T·∫°o `callId`, l∆∞u v√†o `videoCallMap`
3. **Notify User B** ‚Üí `io.to(receiverSocketId).emit("incomingCall")`
4. **User B nh·∫≠n call** ‚Üí `socket.on("incomingCall")`
5. **User B accept** ‚Üí `socket.emit("acceptCall")`
6. **Backend confirm** ‚Üí `io.to(callerSocketId).emit("callAccepted")`
7. **WebRTC setup** ‚Üí Exchange offer/answer/ICE candidates
8. **P2P connection** ‚Üí Direct video/audio stream
9. **UI display** ‚Üí Show video call interface

### **Unread Counts - Step by Step**

1. **User m·ªü chat** ‚Üí `getMessages()` API call
2. **Backend l·∫•y tin nh·∫Øn** ‚Üí `Message.find()`
3. **ƒê√°nh d·∫•u ƒë√£ ƒë·ªçc** ‚Üí `Message.updateMany()`
4. **T√≠nh unread counts** ‚Üí `Message.aggregate()`
5. **Socket emit** ‚Üí `io.to(socketId).emit("unreadCountsUpdate")`
6. **Frontend nh·∫≠n** ‚Üí `socket.on("unreadCountsUpdate")`
7. **UI update** ‚Üí Hi·ªÉn th·ªã badge s·ªë tin nh·∫Øn ch∆∞a ƒë·ªçc

---

## üéØ **T√ìM T·∫ÆT NETWORK PROGRAMMING**

### **3 Giao Th·ª©c Ch√≠nh:**
- **HTTP/HTTPS**: RESTful APIs cho CRUD operations
- **WebSocket**: Real-time messaging v√† notifications
- **WebRTC**: Peer-to-peer video/voice calls

### **Ki·∫øn Tr√∫c:**
- **Frontend**: React + Zustand + Socket.IO Client
- **Backend**: Node.js + Express + Socket.IO Server
- **Database**: MongoDB v·ªõi Mongoose ODM
- **Real-time**: Socket.IO cho messaging, WebRTC cho calls

### **L·ª£i √çch:**
- ‚úÖ Real-time communication
- ‚úÖ Low latency video calls
- ‚úÖ Scalable architecture
- ‚úÖ Secure data transmission
- ‚úÖ Cross-platform compatibility
- ‚úÖ Smart message tracking

---

*T√†i li·ªáu n√†y ƒë∆∞·ª£c t·∫°o ƒë·ªÉ h·ªó tr·ª£ thuy·∫øt tr√¨nh v·ªÅ Network Programming trong d·ª± √°n Chat Ting Ting.*
